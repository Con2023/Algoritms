package CodeRun.DynamicProgramming.Middle;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

/**
 * Вам нужно распилить деревянный брус на несколько кусков в заданных местах. Распилочная компания берет K рублей за распил одного бруска длиной
 * K метров на две части.
 * Понятно, что различные способы распила приводят к различной суммарной стоимости заказа.
 * Например, рассмотрим брус длиной 10 метров, который нужно распилить на расстоянии 2, 4 и 7 м, считая от одного конца.
 * Это можно сделать несколькими способами. Можно распилить сначала на отметке 2 м, потом 4 и, наконец, 7 м. Это приведет к стоимости
 * 10+8+6=24, потому что сначала длина бруса, который пилили, была 10 м, затем она стала 8 м, и, наконец, 6 м.
 * А можно распилить иначе: сначала на отметке 4 м, затем 2, затем 7м. Это приведет к стоимости 10+4+6=20, что лучше.
 * Определите минимальную стоимость распила бруса на заданные части.
 * Формат ввода
 * Первая строка входных данных содержит целое число
 * L (2≤L≤10) — длину бруса и целое число N (1≤N≤100) — количество распилов. Во второй строке записано
 * N целых чисел С(0<C<L) в строго возрастающем порядке — места, в которых нужно сделать распилы.
 * Формат вывода
 * Выведите одно натуральное число — минимальную стоимость распила.
 */
public class Task1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] firstString = scanner.nextLine().split(" ");
        int height = Integer.parseInt(firstString[0]);
        int count = Integer.parseInt(firstString[1]);

        String[] secondString = scanner.nextLine().split(" ");
        ArrayList<Integer> nums = new ArrayList<>();
        for(String el : secondString){
            nums.add(Integer.parseInt(el));
        }
        //1. Находим нулевые(фиктивные) значения. У нас точи распила обозначены С. Выпишем С0 =0 и Сn+1 = длине бруска. По этим числам будем составлять таблицу.
        nums.addFirst(0);
        nums.addLast(height);
        System.out.println(nums);

        //2. Создаем массив распилов, точнее стоимостей из которых будем выбирать минимальную. Размер +2, так как добавляем две фиктивные точки.
        int[][]dp = new int[count+2][count+2];

        //3. Устанавливаем базовый случай. Распилы между 0-2, 2-4, 4-7,7-10 невозможны, так как это цельные бруски.
        //код необязателен так как по умолчанию все элементы равны 0 при создании массива.
//        for(int i = 0; i<count+1; i++){
//            dp[i][i+1] = 0;
//        }

        System.out.println(Arrays.deepToString(dp));

        //4. Рекуррентное соотношение.
        for (int j = 2; j<=count+1;j++){
            System.out.println(j);
            for (int i = j-2; i>=0; i--){
                dp[i][j] = Integer.MAX_VALUE;
                for(int k = i+1;k<j;k++){
                    int cost = dp[i][k]+dp[k][j]+(nums.get(j)-nums.get(i));
                    if(cost < dp[i][j]){
                        dp[i][j] = cost;
                    }
                }
            }
        }

        // Выводим минимальную стоимость распила всего бруса
        System.out.println(dp[0][count + 1]);
    }
}
