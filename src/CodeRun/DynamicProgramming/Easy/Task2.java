package CodeRun.DynamicProgramming.Easy;


import java.util.Scanner;

/**
 * Дана прямоугольная доскаN×M (N строк и M столбцов).
 * В левом верхнем углу находится шахматный конь, которого необходимо переместить в
 * правый нижний угол доски. В данной задаче конь может перемещаться на две клетки
 * вниз и одну клетку вправо или на одну клетку вниз и две клетки вправо.
 * Необходимо определить, сколько существует различных маршрутов,
 * ведущих из левого верхнего в правый нижний угол.
 * Формат ввода
 * Входной файл содержит два натуральных числа (1⩽N, M⩽50).
 * Формат вывода
 * В выходной файл выведите единственное число — количество способов добраться конём
 * до правого нижнего угла доски
 */
public class Task2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int M = scanner.nextInt();

        //1. Создаем массив(объект)((в нашей задаче двумерный, так как участвуют столбцы и строки)), в котором булем работать по заранее извесным размерам. Особенность ДП.
        int[][] dp = new int[N+1][M+1]; //берётся с запасом на единицу по каждой размерности, чтобы удобно индексировать элементы с 1, а не с 0
        //2. Обозначаем начальное значение. Задаем старт.
        dp[1][1] = 1;
        //3. Рекуррентное соотношение (формула перехода). В нашей задаче, чтобы попасть в клетку (i,j) можно использовать вот такой ход - (i-2,j-1) или такой - (i-1,j-2).
        // Нам нужно достигнуть конечной точки. Мы будем двигаться вниз по УЖЕ ИЗВЕСТНЫМ координатам. Их значения будут известны, останется посчитать следующие. Так как у нас два пути, то мы их сложим, если одно из значений изнасально 0, а второе 1, то в эту клетку можно попасть одним способом, если оба нуля, то никаким и т.д.
        // Определим i и j с 2, так как мы изначально определили начальное значение в 1;1 и первая строка и столбац автоматически получаются 0.
        for(int i = 2; i<=N;i++){
            for (int j = 2; j <= M; j++){
                dp[i][j] = dp[i-2][j-1] + dp[i-1][j-2];
            }
        }

        System.out.println(dp[N][M]); //выводим последний элемент, который нужно найти.
    }
}
